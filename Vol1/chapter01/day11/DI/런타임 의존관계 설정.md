# 1.7.2  런타임 의존관계 설정(p.112 ~ 117)

## 의존관계

- 두 개의 클래스 또는 모듈이 의존관계에 있다고 말할 때는 항상 방향성(누가 누구에게 의존하는 관계에 있다)을 부여해줘야 한다.

- UML 모델에서는 두 클래스의 의존관계(dependency relationship)를 점선으로 된 화살표로 표현한다.

  그림1-10 클래스의 의존관계 다이어그램 (A가 B에 의존)
  <img src="https://images.velog.io/images/devsigner9920/post/444c8977-46f0-4308-86de-896a1737e568/8C9D93F9-A4D6-45D6-A23D-82B5783342D0.png">

  - '의존한다' 의미
    
     의존대상(B)가 변하면 A에 영향을 미친다는 뜻이다.

     B의 기능이 추가되거나 변경되거나, 형식이 바뀌거나 하면 그 영향이 A로 전달된다는 것이다.

  - 예시

      - A가 B를 사용하는 경우, A에서 B에 정의된 메소드를 호출해서 사용하는 경우다(사용에 대한 의존관계). 
      
      - B에 새로운 메소드가 추가되거나 기존 메소드의 형식이 바뀌면 A도 그에 따라 수정되거나 추가돼야 할 것이다. 또는 B의 형식은 그대로지만 기능이 내부적으로 변경되면, 결과적으로 A의 기능이 수행되는 데도 영향을 미칠 수 있다.

      - 사용의 관계에 있는 경우에 A와 B는 의존관계가 있다고 말할 수 있다.

      - 의존관계에는 방향성이 있다는 말은 A가 B에 의존하고 있지만, 반대로 B는 A에 의존하지 않는다.

      - 의존하지 않는다는 말은 B는 A의 변환에 영향을 받지 않는다는 뜻이다.

<br />

## UserDao의 의존관계

그림 1-11. 인터페이스를 통한 느슨한 결합을 갖는 의존관계

<img src="https://velog.velcdn.com/images%2Fdevsigner9920%2Fpost%2Ff1ef3583-5521-4be4-a259-fcf6edff3428%2F58808FE3-0CE5-4A1B-A9BC-C825FB07DB22.png">

  <br />

- UserDao는 ConnectionMaker 인터페이스에만 의존하고 있다.

  - ConnectionMaker 인터페이스가 변한다면 UserDao가 직접적으로 영향을 받게 된다.

  - ConnectionMaker 인터페이스를 구현한 클래스 DConnectionMaker 등 내부 변화는 UserDao에 영향을 주지 않는다.

  - 인터페이스에 대해서만 의존관계를 만들어두면 인터페이스 구현 클래스와의 관계는 느슨해지면서 변화에 영향을 덜 받는 상태가 된다.(결합도가 낮다)

- 의존관계란 한쪽의 변화가 다른 쪽에 영향을 주는 것인데, 인터페이스를 통해 의존관계를 제한해주면 그만큼 변경에서 자유로워진다.

- UML에서 말하는 의존관계란 설계 모델의 관점에서 이야기하는 것이다. 

- 모델이나 코드에서 클래스와 인터페이스를 통해 드러나는 의존관계가 아닌 런타임 시에 오브젝트 사이에서 생성되는 런타임 의존관계 또는 오브젝트 의존관계는 설계 시점의 의존관계가 실체화된 것이다.
  
  - 인터페이스를 통해 설계 시점에 느슨한 의존관계를 갖는 경우에는 UserDao의 오브젝트가 런타임 시에 사용할 오브젝트가 어떤 클래스로 만든 것인지 미리 알 수 없다. 
  
  - 프로그램이 시작되고 userDao 오브젝트가 만들어지고 나서 런타임 시에 의존관계를 맺는 대상, 즉 실제 사용대상인 오브젝트를 의존 오브젝트(dependent object)라고 한다.

- 의존관계 주입은 구체적인 의존 오브젝트와 그것을 사용할 주체, 보통 클라이언트라고 부르는 오브젝트를 런타임 시에 연결해주는 작업을 말한다.

- 의존관계 주입은 3가지 조건을 충족하는 작업을 말한다.
  
  - 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야 한다.

  - 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정한다.

  - 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.

- 의존관계 주입의 핵심은 설계 시점에는 알지 못했던 두 오브젝의 관게를 맺도록 도와주는 제 3의 존재가 있다는 것이다.

  - 제 3의 존재는 관게설정 책임을 가진 코드를 분리해서 만들어진 오브젝트이다.

  - 전략 패턴에 등장하는 클라이언트나 앞에서 만들었던 DaoFactory, 또는 DaoFactory와 같은 작업을 일반화해서 만들어졌다는 스프링의 애플리케이션 컨텍스트, 빈 팩토리, IoC 컨테이너 등이 모두 외부에서 오브젝트 사이의 런타임 관계를 맺어주는 책임을 지닌 제 3의 존재라 할 수 있다. 

<br />

## UserDao의 의존관계 주입

- 인터페이스를 사이에 두고 UserDao와 ConnectionMaker 구현 클래스 간에 의존관계를 느슨하게 만들긴 했지만, UserDao가 사용할 구체적인 클래스를 알고 있어야 한다.

리스트 1-24. 관계설정 책임 분리 전의 생성자
```Java
public UserDao(){
    connectionMaker = new DConnectionMaker();
}
```

- UserDao는 이미 설계 시점에서 DConnectionMaker라는 구체적인 클래스의 존재를 알고 있다. 따라서 모델링 때의 의존관계, 즉 ConnectionMaker 인터페이스의 관계뿐 아니라 런타임 의존관계, 즉 DConnectionMaker 오브젝트를 사용하겠다는 것까지 UserDao가 결정하고 관리하고 있다.

- 문제는 이미 런타임 시에 의존관계가 코드 속에 다 미리 결정되어 있다는 것이다. 
  
  - IoC 방식을 써서 UserDao로부터 런타임 의존관계를 드러내는 코드를 제거하고, 제 3의 존재에 런타임 의존관계 결정 권한을 위임한다. 

  - DaoFactory는 런타임 시점에 UserDao가 사용할 ConnectionMaker 타입의 오브젝트를 결정하고 이를 생성한 후에 UserDao 생성자 파라미터로 주입해서 UserDao가 DConnectionMaker의 오브젝트와 런타임 의존관계를 맺게 해준다.

  그림 1-12. 클래스/코드 레벨의 의존관계

  <img src="https://leejaedoo.github.io/assets/img/%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84.jpeg">

  - UserDao의 의존관계는 ConnectionMaker 인터페이스뿐이다. 

    - 클래스 모델의 의존관계이므로 코드에 반영되고, 런타임 시점에서도 변경되지 않는다.

<br />

  - DaoFactory는 두 오브젝트 사이의 런타임 의존관계를 설정해주는 의존관계 주입 작업을 주도하는 존재이며, 동시에 IoC 방식으로 오브젝트의 생성과 초기화, 제공 등의 작업을 수행하는 컨테이너다. 의존관계 주입을 담당하는 컨테이너라 볼 수 있고 줄여서 DI 컨테이너라고 할 수 있다.

리스트 1-25 의존관계 주입을 위한 코드
```Java
public class UserDao{
    private ConnectionMaker connectionMaker;

    public UserDao(ConnectionMaker connectionMaker){
        this.connectionMaker = connectionMaker;
    }
}
```

- DI 컨테이너에 의해 런타임 시에 의존 오브젝트를 사용할 수 있도록 레퍼런스를 전달받는 과정이 메소드(생성자)를 통해 DI 컨테이너가 UserDao에게 주입해주는 것과 유사하여 의존관계 주입이라 한다.

그림 1-13. 런타임 시의 의존관계 주입과 사용 의존관계
<img src="https://t1.daumcdn.net/cfile/tistory/991506445AA7BB2A08">