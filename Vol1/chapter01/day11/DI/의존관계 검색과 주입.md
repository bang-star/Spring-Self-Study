# 1.7.3 의존관계 검색과 주입(p.117 ~ 119)

- 의존관계 검색
  
  - 코드에서 구체적인 클래스에 의존하지 않고, 런타임 시에 의존관계를 결정하는 것은 의존관계 주입과 비슷하지만, 의존관계를 맺는 방법이 외부로부터의 주입이 아니라 스스로 검색을 이용하는 방법

  - 의존관계 검색은 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾고, 자신이 어떤 클래스의 오브젝트를 이용할지 결정하지 않기 때문에 IoC라고 할 수 없다.

  - 의존관계 검색은 런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성 작업은 외부 컨테이너에게 IoC로 맡기지만, 이를 가져올 때는 메소드나 생성자를 통한 주입 대신 스스로 컨테이너에게 요청하는 방법을 사용한다.

리스트 1-26. DaoFactory를 이용하는 생성자
```Java
public UserDao(){
    DaoFactory daoFactory = new DaoFactory();
    this.connectionMaker = daoFactory.connectionMaker();
}
``` 

- 코드의 의존대상은 런타임 시에 DaoFactory가 만들어서 돌려주는 오브젝트와 다이내믹하게 런타임 의존관계를 맺는다.

- 적용 방법은 외부로부터의 주입이 아니라 스스로 IoC 컨테이너인 DaoFactory에게 요청하는 것이다. 

- DaoFactory의 경우라면 미리 준비된 메소드를 호출하면 되니까 이런 작업을 일반화한 스프링의 애플리케이션 컨텍스트라면 미리 정해놓은 이름을 전달해서 그 이름에 해당하는 오브젝트를 찾게 된다.

- 일종의 검색이며 대상이 런타임 의존관계를 가질 오브젝트이므로 의존관계 검색이라 부르는 것이다.

- 스프링의 IoC 컨테이너인 애플리케이션 컨텍스트는 getBean() 메소드가 의존관계 검색에 사용된다.

- UserDao는 리스트 1-27과 같이 애플리케이션 컨텍스트를 사용해서 의존관계 검색 방식으로 Connectionmaker 오브젝트를 가져오게 만들 수 있다.

리스트 1-27. 의존관계 검색을 이용하는 UserDao 생성자
```Java
public UserDao(){
    AnnotaionConfigApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
    this.connectionMaker = context.getBean("connectionMaker", ConnectionMaker.class);
}
```

- 의존관계 검색은 기존 의존관계 주입의 거의 모든 장점을 갖고 있고 IoC 원칙에도 잘 들어맞지만, 방법은 조금 다르다.

- 의존관계 검색과 의존관계 주입 방법 비교
  
  - 코드측면

    - 의존관계 주입이 훨씬 단순하고 깔끔하다.
    
    - 의존관계 검색은 코드에 오브젝트 팩토리 클래스나 스프링 API가 나타난다. 애플리케이션 컴포넌트가 컨테이너와 같이 성격이 다른 오브젝트에 의존하게 되는 것이므로 바람직하지 않다.

    - 사용자에 대한 DB 정보를 어떻게 가져올 것인가에 집중해야 하는 UserDao에서 스프링이나 오브젝트 팩토리를 만들고 API를 이용하는 코드가 섞여 있는 것은 어색하다. 보통 의존관계 주입 방식을 사용하는 편이 낫다.

  - 의존관계 검색 방식을 사용해야하는 경우
    
     - 테스트 코드 UserDaoTest에서 이미 의존관계 검색 방식인 getBean()을 사용하였다. 스프링의 IoC와 DI 컨테이너를 적용했다고 하더라도 애플리케이션의 기동시점에서 적어도 한 번은 의존관계 검색 방식을 사용해 오브젝트를 가져와야 한다. static 메소드인 main()에서는 DI를 이용해 오브젝트를 주입받을 방법이 없기 때문이다. 

     - 서버에는 main()과 같은 기동 메소드는 없지만, 사용자의 요청을 받을 때마다 main() 메소드와 비슷한 역할을 하는 서블릿에서 스프링 컨테이너에 담긴 오브젝트를 사용하려면 한 번은 의존관계 검색 방식을 사용해 오브젝트를 가져와야 한다.  
     ( 스프링이 미리 만들어서 제공하기 때문에 직접 구현할 필요는 없다 )

  - 의존관계 검색과 주입을 적용할 때 발견할 수 있는 차이점
  
    -  의존관계 검색 방식에서 검색하는 오브젝트는 자신이 스프링의 빈일 필요가 없다. 
      
       - UserDao에 스프링의 getBean()을 사용한 의존관계 검색 방법을 적용했을 때 UserDao는 스프링이 만들고 관리하는 빈일 필요가 없고 ConnectionMaker만 스프링의 빈이기만 하면 된다.

    <br />

    - 의존관계 주입 방식에서는 UserDao와 ConnectionMaker 사이에 DI가 적용되려면 UserDao는 반드시 컨테이너가 만드는 빈 오브젝트여야 한다.
    
       - 컨테이너가 UserDao에 ConnectionMaker 오브젝트를 주입해주려면 UserDao에 대한 생성과 초기화 권한을 갖고 있어야 한다. 이를 위해 UserDao는 IoC방식으로 컨테이너에서 생성되는 오브젝트(빈)이어야 한다.

  - DI를 원하는 오브젝트는 먼저 자기 자신이 컨테이너가 관리하는 빈이 돼야 한다.

```
* DI 받는다.

- DI의 동작방식은 이름 그대로 외부로부터의 주입이다. 하지만 단지 외부에서 파라미터로 오브젝트를 넘겨줬다고 해서, 즉 주입해줬다고 해서 다 DI가 아니라는 점을 주의해야 한다. 주입받는 메소드 파라미터가 이미 특정 클래스 타입으로 고정되어 있다면 DI가 일어날 수 없다. DI에서 말하는 주입은 다이내믹하게 구현 클래스를 결정해서 제공받을 수 있도록 인터페이스 타입의 파라미터를 통해 이뤄져야 한다.
```

