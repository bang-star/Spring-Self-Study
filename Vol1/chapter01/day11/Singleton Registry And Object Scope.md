# 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트

## 싱글톤 패턴의 한계

- (자바) 싱글톤 구현 방법

  - 클래스 밖에서는 오브젝트를 생성하지 못하도록 생성자를 private으로 만든다.

  - 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 스태틱 필드를 정의한다.

  - 스태틱 팩토리 메소드인 getInstance()를 만들고 이 메소드가 최초로 호출되는 시점에서 한 번만 오브젝트가 만들어지게 한다. 

  - 생성된 오브젝트는 스태틱 필드에 저장하거나 스태틱 필드의 초기값으로 오브젝트를 미리 만들어둘 수 있다.
  - 한번 오브젝트(싱글톤)가 만들어지고 난 후에는 getInstance() 메소드를 통해 이미 만들어져 스태틱 필드에 저장해둔 오브젝트를 넘겨준다.

리스트 1-22. 싱글톤 패턴을 적용한 UserDao
```Java
public class UserDao {

    private static UserDao INSTANCE;

    private UserDao(ConnectionMaker connectionMaker){
        this.connectionMaker = connectionMaker;  
    }
    
    public static synchronized UserDao getInstance(){
        if(INSTANCE == null) INSTANCE = new UserDao(???);
        return INSTANCE;
    }
}
```

- 싱글톤 패턴 적용 결과

  - 코드가 상당히 지저분해졌다.

  - 접근지정자가 public -> private으로 바뀐 생성자는 외부에서 호출할 수가 없기 때문에 DaoFactory에서 UserDao를 생성하여 ConnectionMaker 오브젝트를 넣어주는 방법이 불가능해졌다.

<br />

- 싱글톤 패턴 구현 방식의 문제점
  
  - private 생성자를 갖고 있기 때문에 상속할 수 없다.
    
    - 싱글톤 클래스 자신만이 자기 오브젝트를 만들도록 제한하는 것이다. 

    - private 생성자를 가진 클래스는 다른 생성자가 없다면 상속이 불가능해진다.

    - 객체지향의 장점인 상속과 다형성을 적용할 수 없다.

    - 기술적인 서비스만 제공하는 경우라면 상관없겠지만, 애플리케이션의 로직을 담고 있는 일반 오브젝트의 경우 싱글톤으로 만들었을 때 객체지향적인 설게의 장점을 적용하기 어렵다.

    - 상속과 다형성 같은 객체지향의 특징이 적용되지 않는 static 필드와 메소드를 사용하는 것도 동일한 문제가 발생한다.
  
  <br />

  - 싱글톤은 테스트하기 힘들다.
 
    - 싱글톤은 테스트하기가 어렵거나 테스트 방법에 따라 테스트가 불가능하다.

    - 싱글톤은 만들어지는 방식이 제한적이기 때문에 테스트에서 사용될 때 Mock 오브젝트 등으로 대체하기가 힘들다.

    - 싱글톤은 초기화 과정에서 생성자 등을 사용할 오브젝트를 다이내믹하게 주입하기도 힘들기 때문에 필요한 오브젝트는 직접 오브젝트를 만들어 사용할 수 밖에 없다.

    - 테스트는 엔터프라이즈 개발의 핵심인데 애플리케이션 코드를 싱글톤으로 만들면 테스트를 마드는 데 지장이 있다는 단점이 있다. 

  <br />

  - 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
    
    - 서버에서 클래스 로더를 어떻게 구성하고 있느냐에 따라서 싱글톤 클래스임에도 하나 이상의 오브젝트가 만들어질 수 있다.
    
    - 자바 언어를 이용한 싱글톤 패턴 기법은 서버환경에서는 싱글톤이 꼭 보장된다고 볼 수 없다. 이유는 여러 개의 JVM에 분산돼서 설치가 되는 경우에도 각각 독립적으로 오브젝트가 생기기 때문에 싱글톤으로서의 가치가 떨어진다.

  <br />

  - 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.

    - 싱글톤은 사용하는 클라이언트가 정해져 있지 않다. 

    - 싱글톤의 스태틱 메소드를 이용해 언제든지 싱글톤에 쉽게 접근할 수 있기 때문에 애플리케이션 어디서든지 사용될 수 있어 전역 상태(global state)로 사용되기 쉽다.
    
    - 아무 객체나 자유롭게 접근하고 수정하고 공유할 수 있는 전역 상태를 갖는 것은 객체지향 프로그래밍에서는 권장되지 않는 프로그래밍 모델이다.