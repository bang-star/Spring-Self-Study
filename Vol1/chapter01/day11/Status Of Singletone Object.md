# 1.6.2 싱글톤과 오브젝트의 상태(p.109 ~ 110)

- 싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있다.

- 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에 상태정보를 내부에 갖고 있지 않은 무상태(Stateless) 방식으로 만들어져야 한다.

  - 다중 사용자의 요청을 한꺼번에 처리하는 스레드들이 동시에 싱글톤 오브젝트의 신스턴스 변수를 수정하는 것은 매우 위험하다. 저장할 공간이 하나뿐이니 서로 값을 덮어쓰고 자신이 저장하지 않은 값을 읽어올 수 있기 때문이다.

<br />

- 싱글톤은 기본적으로 인스턴스 필드의 값을 변경하고 유지하는 상태유지(stateful)방식으로 만들지 않는다.

  - 상태유지 방식으로 만들게 되면 혼자서 개발하고 테스트할 때는 아무런 문제가 없지만, 서버에 배포되고 여러 사용자가 동시에 접속하면 데이터가 엉망이 돼버리는 등의 심각한 문제가 발생할 수 있다. 읽기전용의 값이라면 초기화 시점에서 인스턴수 변수에 저장해두고 공유하는 것은 아무 문제가 없다.

<br />

- 상태가 없는 방식으로 클래스를 만드는 경우에 각 요청에 대한 정보, DB 또는 서버의 리소스로부터 생성한 정보는 파라미터와 로컬 변수, 리턴 값 등을 이용하면 된다. 메소드 파라미터나 메소드 안에서 생성되는 로컬 변수는 매번 새로운 값을 저장할 독립적인 공간이 만들어지기 때문이다.

리스트 1-23 인턴스 변수를 사용하도록 수정한 UserDao
```Java
public class UserDao {
    private ConnectionMaker connectionMaker; // 초기에 설정하면 사용 중에는 바뀌지 않는 읽기전용 인스턴스 변수
    private Connection c;   // 매번 새로운 값으로 바뀌는 정보를 담은 인스턴스 변수. 심각한 문제가 발생한다.
    private User user;

    public User get(String id) throws ClassNotFoundException, SQLException {
        this.c = connectionMaker.makeconnection();
        this.user = new User();
        this.user.setId(rs.getString("id"));
        ...
        return this.user;
    }
}
```

- 스프링의 싱글톤 빈으로 사용되는 클래스를 만들 때는 기존의 UserDao처럼 개별적으로 바뀌는 정보는 로컬 변수로 정의하거나, 파라미터로 주고받으면서 사용하게 해야 한다.

- ConnectionMaker 인터페이스 타입의 connectionMaker는 인스턴스 변수를 사용해도 상관없다.
  
  - connectionMaker는 읽기전용의 정보이기 때문

- 자신이 사용하는 다른 싱글톤 빈을 저장하려는 용도라면 인스턴스 변수를 사용해도 좋다. 스프링이 한번 초기화해주고 나면 이후에는 수정되지 않기 때문에 멀티스레드 환경에서 사용해도 아무런 문제가 없다.
