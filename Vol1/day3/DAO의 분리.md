# 1.2 DAO 분리

## 1.2.1 관심사 분리

- 객체지향의 세계에서는 모든 것이 변한다. 값을 의미하는 것이 아니라 오브젝트에 대한 설계와 이를 구현한 코드가 변한다는 의미이다.

    - 사용자의 비즈니스 프로세스와 그에 따른 요구사항은 끊임없이 바뀌고 발전한다.
    - 애플리케이션이 기반을 두고 있는 기술도 시간이 지남에 따라 바뀌고, 운영되는 환경도 변화한다.
    - 애플리케이션이 더 이상 사용되지 않아 폐기처분될 때가 돼어야 변화는 중지된다.

> 지혜로운 개발자는 오늘 이 시간에 미래를 위해 설계하고 개발한다.

- 객체지향 설계와 프로그래밍이 이전의 절차적 프로그래밍 패러다임에 비해 초기에 좀 더 많은, 번거로운 작업을 요구하는 이유는 객체지향 기술 자체가 지니는, 변화에 효과적으로 대처할 수 있다는 기술적인 특징 때문이다.
- 객체지향 기술은 흔히 실세계를 최대한 가깝게 모델링해낼 수 있기 때문에 의미가 있다고 여겨진다. 하지만 그보다는 객체지향 기술이 만들어내는 가상의 추상세계 자체를 효과적으로 구성할 수 있고, 이를 자유롭고 편리하게 변경, 발전, 확장시킬 수 있다는데 더 의미가 있다.

<br />

### 미래를 준비하기 위해 변화에 어떻게 대비할 것인가?
  
    1. 변화의 폭을 최소한으로 줄여주는 것이다.
    (예시) 두명의 개발자가에게 동일한 기능 변경을 요청했다고 했을 때, 
    한 명은 단 몇줄의 코드만 수정하고, 그 변경이 나머지 기능에는 전혀 문제를 일으키지 않는다는 것까지 검증해주는 데 5분이 걸렸다. 
    다른 한명은 동일한 기능을 변경하는 데 5시간이 걸리고, 기존에 잘 동작하던 다른 기능에 오류를 일으킬지도 모른다는 새로운 불안감까지 일으켰다.

    이중 어떤 개발자가 더 미래의 변화를 잘 준비한 것일까?
    > 최소한의, 확신을 가진 작업만으로도 기능을 수정해낸 개발자다.
     변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 하기 위해서는 분리와 확장을 고려한 설계가 있었기 때문이다. 
    
- 모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다.
- 관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 하는 것이 중요하다.
    
    - 프로그래밍의 기초 개념 중 관심사의 분리(Separation of Concerns)을 객체지향에 적용해보면, 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 따로 떨여져서 서로 영향을 주지 않도록 분리하는 것이라고 생각할 수 있다.
    - 관심사가 같은 것끼리 모으고 다른 것은 분리해줌으로써 같은 관심에 효과적으로 집중할 수 있게 만들어주는 것이다.

<br />
<hr />
<br />

## 1.2.2 커넥션 만들기의 호출

- UserDato의 구현된 add 메소드 하나에서만 적어도 3가지 관심사항을 발견할 수 있다.

```Java
public Users get(String id) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.cj.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "root", "root");

        PreparedStatement ps = c.prepareStatement(
                "select * from users where id = ?");
        ps.setString(1, id);

  public void add(Users user) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.cj.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "spring", "book");
        PreparedStatement ps = c.prepareStatement(
                "insert into users(id, name, password) values(?, ?, ?)");

        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());

    ps.executeUpdate();                                 // Query 실행

        ps.close();                                     // preparedStatement 닫기
        c.close();                                      // Connection 종료
    }      ResultSet rs = ps.executeQuery();
        rs.next();

        Users user = new Users();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));

        rs.close();
        ps.close();
        c.close();

        return user;
    }
```

    1. 첫째는 DB와 연결을 위한 Connection을 어떻게 가져올까라는 관심이다.

        - 어떤 DB를 사용할 것인가?
        - 어떤 드라이버를 사용할 것인가?
        - 어떤 로그인 정보를 사용할 것인지?
        - Connection을 생성하는 방법은 어떤 것인지?
    
    > 크게 보면 DB연결

    2. 둘째는 사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행하는 것

        - 파라미터로 넘어온 사용자 정보를 Statement에 바인딩시키는 것
        - Statement에 담긴 SQL을 DB를 통해 실행시키는 방법
    >  파라미터를 바인딩하는 것과 어떤 SQL을 사용할지를 다른 관심사로 분리할 수 있지만, 하나로 보자

    3. 셋째는 작업이 끝나면 사용한 리소스인 Statement와 Connection 오브젝트를 닫아줘서 소중한 공유리소스를 시스템에 돌려주는 것

<br />

### 문제점 
1. 예외상황에 대한 처리
2. DB연결을 위한 Connection 오브젝트를 가져오는 부분
> 현재 DB Connection을 가져오는 코드는 다른 관심사와 섞여서 같은 add() 메소드에 담겨 잇다.

3. add() 메소드에 있는 DB 커넥션을 가져오는 코드와 동일한 코드가 get 메소드에도 중복되어 있다.

<br />

### 중복 코드의 메소드 추출
1. 중복된 코드를 적절한 메소드 명을 사용하여 분리하는 방법
2. 상속을 통해 서브 클래스로 분리하는 방법

<br />

### 변경사항에 대한 검증 : 리팩토링과 테스트

- 문제점
    
    1. 수정한 기능에 문제가 없다는 게 보장되지 않는다.
    2. main 메소드에 작성한 테스트 코드는 두 번째 부터 에러가 예외가 발생(id 중복)
    3. 2번 문제 해결을 위해 매 실행시 사용자 정보를 모두 삭제해야한다.

<br />

- 리팩토링 : 기능이 추가되거나 바뀐 것 없이 이전보다 코드를 깔끔하게 변경하는 것

    - 메소드 추출은 리팩토링 기법 중 하나이다.

```
리팩토링
- 리팩토링은 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술을 말한다. 리팩토링을 하면 코드 내부의 설계가 개선되어 코드를 이해하기가 더 편해지고, 변화에 효율적으로 대응할 수 있다.
- 리팩토링이 절실히 필요한 코드의 특징은 나쁜 냄새라고 한다. 대표적으로, 매우 흔하게 발견되는 나쁜 냄새다. 
- 리팩토링은 개발자가 직관적으로 수행할 수 있긴 하지만, 본격적으로 적용하자면 학습과 훈련이 필요하다. 나쁜 냄새에는 어떤 종류가 있고, 그에 따른 적절한 리팩토링 방법은 무엇인지 보고, 충분한 연습을 해두면 도움이 된다. 리팩토링을 공부할 때는 리팩토링에 관해 체계적으로 잘 정히한 책인 [리팩토링](마틴 파울러, 켄트 벡 공저)를 추천한다.
```

<br />
<hr />
<br />

## 1.2.3 DB Connection 만들기 독립

### 상속을 통한 확장
- 기존 UserDto 코드를 한 단계 더 분리하는 방법

    - add, get 메소드에서 getConnection을 호출하는 코드는 그대로 유질 할 수 있다.
    - 기존 같은 클래스에 다른 메소드로 분리됐던 DB 커넥션 연결이라는 관심을 상속을 통해 서브클래스로 분리해버리는 것이다.


- 수정 코드 분석

    - DAO의 핵심 기능은 어떻게 데이터를 등록하고 가져올 것인가라는 관심을 담당
    - DB연결 방법은 어떻게 할 것인가라는 관심을 담고 있는 NUserDao, DUserDao가 클래스 레벨로 구분되고 있다.

```
템플릿 메소드 패턴
- 슈퍼 클래스에 기본적인 로직의 흐름(커넥션 가져오기, SQL 생성, 실행, 반환)을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법
```

> 즉, UserDao의 getConnection() 메소드는 Connection타입 오브젝트를 생성한다는 기능을 정의해놓은 추상 메소드다.

```
팩토리 메소드 패턴
- 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것
```


