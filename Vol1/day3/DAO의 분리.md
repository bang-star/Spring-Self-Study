# 1.2 DAO 분리

## 1.2.1 관심사 분리

- 객체지향의 세계에서는 모든 것이 변한다. 값을 의미하는 것이 아니라 오브젝트에 대한 설계와 이를 구현한 코드가 변한다는 의미이다.

    - 사용자의 비즈니스 프로세스와 그에 따른 요구사항은 끊임없이 바뀌고 발전한다.
    - 애플리케이션이 기반을 두고 있는 기술도 시간이 지남에 따라 바뀌고, 운영되는 환경도 변화한다.
    - 애플리케이션이 더 이상 사용되지 않아 폐기처분될 때가 돼어야 변화는 중지된다.

> 지혜로운 개발자는 오늘 이 시간에 미래를 위해 설계하고 개발한다.

- 객체지향 설계와 프로그래밍이 이전의 절차적 프로그래밍 패러다임에 비해 초기에 좀 더 많은, 번거로운 작업을 요구하는 이유는 객체지향 기술 자체가 지니는, 변화에 효과적으로 대처할 수 있다는 기술적인 특징 때문이다.
- 객체지향 기술은 흔히 실세계를 최대한 가깝게 모델링해낼 수 있기 때문에 의미가 있다고 여겨진다. 하지만 그보다는 객체지향 기술이 만들어내는 가상의 추상세계 자체를 효과적으로 구성할 수 있고, 이를 자유롭고 편리하게 변경, 발전, 확장시킬 수 있다는데 더 의미가 있다.

<br />

### 미래를 준비하기 위해 변화에 어떻게 대비할 것인가?
  
    1. 변화의 폭을 최소한으로 줄여주는 것이다.
    (예시) 두명의 개발자가에게 동일한 기능 변경을 요청했다고 했을 때, 
    한 명은 단 몇줄의 코드만 수정하고, 그 변경이 나머지 기능에는 전혀 문제를 일으키지 않는다는 것까지 검증해주는 데 5분이 걸렸다. 
    다른 한명은 동일한 기능을 변경하는 데 5시간이 걸리고, 기존에 잘 동작하던 다른 기능에 오류를 일으킬지도 모른다는 새로운 불안감까지 일으켰다.

    이중 어떤 개발자가 더 미래의 변화를 잘 준비한 것일까?
    > 최소한의, 확신을 가진 작업만으로도 기능을 수정해낸 개발자다.
     변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 하기 위해서는 분리와 확장을 고려한 설계가 있었기 때문이다. 
    
- 모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다.
- 관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 하는 것이 중요하다.
    
    - 프로그래밍의 기초 개념 중 관심사의 분리(Separation of Concerns)을 객체지향에 적용해보면, 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 따로 떨여져서 서로 영향을 주지 않도록 분리하는 것이라고 생각할 수 있다.
    - 관심사가 같은 것끼리 모으고 다른 것은 분리해줌으로써 같은 관심에 효과적으로 집중할 수 있게 만들어주는 것이다.

<br />
<hr />
<br />

## 1.2.2 커넥션 만들기의 호출

- UserDato의 구현된 add 메소드 하나에서만 적어도 3가지 관심사항을 발견할 수 있다.

```Java
public Users get(String id) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.cj.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "root", "root");

        PreparedStatement ps = c.prepareStatement(
                "select * from users where id = ?");
        ps.setString(1, id);

  public void add(Users user) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.cj.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "spring", "book");
        PreparedStatement ps = c.prepareStatement(
                "insert into users(id, name, password) values(?, ?, ?)");

        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());

    ps.executeUpdate();                                 // Query 실행

        ps.close();                                     // preparedStatement 닫기
        c.close();                                      // Connection 종료
    }      ResultSet rs = ps.executeQuery();
        rs.next();

        Users user = new Users();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));

        rs.close();
        ps.close();
        c.close();

        return user;
    }
```

    1. 첫째는 DB와 연결을 위한 Connection을 어떻게 가져올까라는 관심이다.

        - 어떤 DB를 사용할 것인가?
        - 어떤 드라이버를 사용할 것인가?
        - 어떤 로그인 정보를 사용할 것인지?
        - Connection을 생성하는 방법은 어떤 것인지?
    
    > 크게 보면 DB연결

    2. 둘째는 사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행하는 것

        - 파라미터로 넘어온 사용자 정보를 Statement에 바인딩시키는 것
        - Statement에 담긴 SQL을 DB를 통해 실행시키는 방법
    >  파라미터를 바인딩하는 것과 어떤 SQL을 사용할지를 다른 관심사로 분리할 수 있지만, 하나로 보자

    3. 셋째는 작업이 끝나면 사용한 리소스인 Statement와 Connection 오브젝트를 닫아줘서 소중한 공유리소스를 시스템에 돌려주는 것

<br />

### 문제점 
1. 예외상황에 대한 처리
2. DB연결을 위한 Connection 오브젝트를 가져오는 부분
> 현재 DB Connection을 가져오는 코드는 다른 관심사와 섞여서 같은 add() 메소드에 담겨 잇다.

3. add() 메소드에 있는 DB 커넥션을 가져오는 코드와 동일한 코드가 get 메소드에도 중복되어 있다.

<br />

### 중복 코드의 메소드 추출
1. 중복된 코드를 적절한 메소드 명을 사용하여 분리하는 방법
2. 상속을 통해 서브 클래스로 분리하는 방법

<br />

### 변경사항에 대한 검증 : 리팩토링과 테스트

- 문제점
    
    1. 수정한 기능에 문제가 없다는 게 보장되지 않는다.
    2. main 메소드에 작성한 테스트 코드는 두 번째 부터 에러가 예외가 발생(id 중복)
    3. 2번 문제 해결을 위해 매 실행시 사용자 정보를 모두 삭제해야한다.

<br />

- 리팩토링 : 기능이 추가되거나 바뀐 것 없이 이전보다 코드를 깔끔하게 변경하는 것

    - 메소드 추출은 리팩토링 기법 중 하나이다.

```
리팩토링
- 리팩토링은 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술을 말한다. 리팩토링을 하면 코드 내부의 설계가 개선되어 코드를 이해하기가 더 편해지고, 변화에 효율적으로 대응할 수 있다.
- 리팩토링이 절실히 필요한 코드의 특징은 나쁜 냄새라고 한다. 대표적으로, 매우 흔하게 발견되는 나쁜 냄새다. 
- 리팩토링은 개발자가 직관적으로 수행할 수 있긴 하지만, 본격적으로 적용하자면 학습과 훈련이 필요하다. 나쁜 냄새에는 어떤 종류가 있고, 그에 따른 적절한 리팩토링 방법은 무엇인지 보고, 충분한 연습을 해두면 도움이 된다. 리팩토링을 공부할 때는 리팩토링에 관해 체계적으로 잘 정히한 책인 [리팩토링](마틴 파울러, 켄트 벡 공저)를 추천한다.
```

<br />
<hr />
<br />

## 1.2.3 DB Connection 만들기 독립

### 상속을 통한 확장
- 기존 UserDto 코드를 한 단계 더 분리하는 방법

    - add, get 메소드에서 getConnection을 호출하는 코드는 그대로 유질 할 수 있다.
    - 기존 같은 클래스에 다른 메소드로 분리됐던 DB 커넥션 연결이라는 관심을 상속을 통해 서브클래스로 분리해버리는 것이다.


- 수정 코드 분석

    - DAO의 핵심 기능은 어떻게 데이터를 등록하고 가져올 것인가라는 관심을 담당
    - DB연결 방법은 어떻게 할 것인가라는 관심을 담고 있는 NUserDao, DUserDao가 클래스 레벨로 구분되고 있다.

```
템플릿 메소드 패턴
- 슈퍼 클래스에 기본적인 로직의 흐름(커넥션 가져오기, SQL 생성, 실행, 반환)을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법
```

> 즉, UserDao의 getConnection() 메소드는 Connection타입 오브젝트를 생성한다는 기능을 정의해놓은 추상 메소드다.

```
팩토리 메소드 패턴
- 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것
```

- UserDao는 Connection 인터페이스 타입의 오브젝트라는 것 외에는 관심을 두지 않는다.
- Connection 인터페이스에 정의된 메소드를 사용할 뿐이다.
- UserDao는 어떤 기능을 사용한다는 것에만 관심이 있고, NUserDao나 DUserDao에서는 어떤식으로 Connection 오브젝트를 만들어내는지도 NUserDao와 DUserDao의 관심사항이다.
- 어떤 방으로 Connection 오브젝트를 만들어내는지도 NUserDao와 DUserDao의 관심사항이다.

> 위 내용을 정리하면 "UserDao에 팩토리 메소드 패턴을 적용해서 getConnection()을 분리"한 것이라 말할 수 있다.

<br />
<hr />
<br />

```
디자인 패턴
- 디자인 패턴은 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션을 말한다.

- 모든 패턴에는 간결한 이름이 있어서 잘 알려진 패턴을 적용하고자 할 때 간단히 패턴 이름을 언급하는 것만으로도 설계의 의도와 해결책을 함께 설명할 수 있다는 장점이 있다. 
- 디자인 패턴은 주로 객체지향 설계에 관한 것이고, 대부분 객체 지향적 설계 원칙을 이용해 문제를 해결한다.
- 패턴의 설계 구조를 보면 대부분 비슷한데, 그 이유는 객체지향적인 설계로부터 문제를 해결하기 위해 적용할 수 있는 확장성 추구 방법이 대부분 두가지 구조로 정리되기 때문이다.

1. 클래스 상속
2. 오브젝트 합성

- 패턴에서 가장 중요한 것은 각 패턴의 핵심이 담긴 목적 또는 의도다. 패턴을 적용할 상황, 해결해야 할 문제, 솔루션의 구조와 각요소의 역할과 함께 핵심 의도가 무엇인지를 기억해둬야 한다.

- 디자인 패턴을 최초로 집대성한 책인 "GoF의 디자인패턴"(에릭 감마 외) 또는 "Head First Design Patterns"(에릭 프리먼)을 추천한다.

```

### 템플릿 메소드 패턴
- 상속을 통해 슈퍼 클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법
- 변하지 않는 기능은 슈퍼클래스에 만들어두고 자주 변경되며 확장할 기능은 서브클래스에 만들도록 한다.
- 슈퍼 클래스에는 미리 추상 메소드 또는 오바라이드 가능한 메소드를 정의해두고 이를 활용해 코드의 기본 알고리즘을 담고 있는 템플릿 메소드를 만든다.
- 슈퍼클래스에서 디폴트 기능을 정의해두거나 비워뒀다가 서브클래스에서 선택적으로 오버라이드할 수 있도록 만들어둔 메소드를 Hook 메소드라고 한다.

> 템플릿 메소드 패턴 여러 작업들이 완전히 동일한 단계를 갖지만, 일부동작은 각각 다르게 구현해야할 때 사용되는 패턴이다. 

- [참고 - 템플릿 메소드 패턴](https://hudi.blog/template-method-pattern)

```Java
public abstract class Super(){
    public void templateMethod(){
        // 기본 알고리즘 코드
        hookMethod();
        abstractMothod();
    }

    protected void hookMethod(){}           // 선택적으로 오바라이드 가능한 hook 메소드
    public abstract void abstractMethod();  // 서브클래스에서 반드시 구현해야 하는 추상 메소드
}

public class Suc1 extends Super{    // 슈퍼클래스의 메소드를 오버라이드하거나 구현해서 기능을 확장한다. 다양한 확장 클래스를 만들 수 있다.
    protected void hookMethod(){
        ...
    }
    public void abstractMethod(){
        ...
    }
}
```

- 기본 알고리즘 골격을 담은 메소드를 템플릿 메소드라고 하고, 서브클래스에서 오버라이드하거나 구현할 메소드를 사용한다.

```
팩토리 메소드 패턴
- 팩토리 메소드 패턴도 템플릿 메소드 패턴과 마찬가지로 상속을 통해 기능을 확장하게 하는 패턴이다. 
- 슈퍼클래스 코드에서 서브클래스에서는 서브클래스에서 구현할 메소드를 호출해서 필요한 타입의 오브젝트를 가져와 사용한다. 이 메소드는 주로 인터페이스 타입으로 오브젝트를 리턴하므로 서브클래스에서 정확히 어떤 클래스의 오브젝트를 만들어 리턴할지는 슈퍼클래스에서는 알지 못하고, 관심 없다.
- 서브클래스는 다양한 방법으로 오브젝트를 생성하는 메소드를 재정의할 수 있다.
- 서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드를 팩토리 메소드라 하고, 이 방식을 통해 오브젝트 생성 방법을 나머지 로직, 즉 슈퍼클래스의 기본 코드에서 독립시키는 방법을 팩토리 메소드 패턴이라 한다.
- 자바에서는 종종 오브젝트를 생성하는 기능을 가진 메소드를 일반적으로 팩토리 메소드라고 부르기도 한다.
- 팩토리 메소드와 팩토리 메소드 패턴의 팩토리 메소드는 의미가 다르므로 혼동하지 않도록 주의해야 한다.
```

- 템플릿 메소드 패턴 또는 팩토리 메소드 패턴으로 관심사항이 다른 코드를 분리해내고, 서로 독딟적으로 변경 또는 확장할 수 있도록 만드는 것은 간단하면서도 매우 효과적인 방법이다.
- 그러나 이 방법은 상속을 사용했다는 단점이 있다.

    1. 자바는 클래스의 다중 상속을 허용하지 않는다. 단지, 커넥션 객체를 가져오는 방법을 분리하기 위해 상속구조로 만들어버리면, 후에 다른 목적으로 클래스에 상속을 적용하기 힘들다.
    2. 상속을 통한 상하위 클래스의 관계는 생각보다 밀접하다.
    - 상속을 통해 관심이 다른 기능을 분리하고, 필요에 따라 다양한 변신이 가능하도록 확장성을 줬지만, 여전히 상속관계는 다른 관심사에 대해 긴밀한 결합을 허용한다.
    - 서브클래스는 슈퍼클래스의 기능을 직접 사용할 수 있다. 그래서 슈퍼클래스 내부의 변경이 있을 때 모든 서브클래스를 함께 수정하거나 다시 개발해야 할 수도 있다.
    - 반대로 그런 변화에 따른 불편을 주지 않기 위해 슈퍼클래스가 더 이상 변화하지 않도록 제약을 가해야할지 모른다.
    3. 확장된 기능인 DB 커넥션을 생성하는 코드를 다른 DAO 클래스에 적용할 수 없다.