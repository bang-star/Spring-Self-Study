# 1.3.4 원칙과 패턴

## 개방 폐쇄 원칙(OCP)
- 개방 폐쇄 원칙(Open-Closed Principle)을 이용하면 지금까지 해온 리팩토링 작업의 특징과 최종적으로 개선된 설계와 코드의 장점이 무엇인지 효과적으로 설명할 수 있다.

> 개방 폐쇄 원칙은 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다. (예를 들면) UserDao는 DB 연결 방법이라는 기능을 확장하는 데 열려 있고, UserDao에 전혀 영향을 주지 않고도 얼마든지 확장할 수 있게 되어 있다. 동시에 UserDao 자신의 핵심 기능을 구현한 코드는 그런 변화에 영향을 받지 않고 유지할 수 있으므로 변경에는 닫혀 있다고 말할 수 있다.

- 인터페이스를 통해 제공되는 확장 포인트는 확장을 위해 개방되어 있지만, 인터페이스를 이용하는 클래스는 자신의 변화가 불필요하게 일어나지 않도록 굳게 폐쇄되어 있다.

```
객체지향 설계 원칙(SOLID)

- 객체지향 프로그래밍 언어의 종류도 다양하고 객체지향 기술을 받아들이고 적용하는 관점과 기법도 조금씩 차이가 있다.
- 객체지향 설계원칙은 객체지향의 특징을 잘 살릴 수 있는 설계의 특징을 말한다.
- 원칙이라는 것은 어떤 상황에서든 100% 지켜져야 하는 절대적인 기준이라기보다는, 예외는 있겠지만 대부분의 상황에 잘 들어맞는 가이드라인과 같은 것이다.

- 디자인 패턴은 특별한 상황에서 발생하는 문제에 대한 구체적인 솔루션이라고 한다면, 객체지향 설계 원칙은 좀더 일반적인 상황에서 적용 가능한 설계 기준이라고 볼 수 있다.

- SOLID는 아래 5가지 원칙의 첫 글자를 따서 만든 단어다.

  1. SRP(The Single Responsibility Principal)
  : 단일 책임 원칙

  2. OCP(The Open Closed Principal) 
  : 개방 폐쇄 원칙

  3. LSP(The Liskov Substitution Principal)
  : 리스코프 치환 원칙

  4. ISP(The Interface Segretaion Principal)
  : 인터페이스 분리 원칙

  5. DIP(The Dependency Inversion Principal)
  : 의존 관계 역전 원칙
```
* 추천 자료
- [로버트 마틴이 정리한 객체지향 설계 원칙인 SOLID 소개](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod)
- [UML for Java Programming](https://www.csd.uoc.gr/~hy252/references/UML_for_Java_Programmers-Book.pdf)
- [밥 마틴 - 소프트웨어 개발의 지혜:원칙, 디자인 패턴, 실천 방법](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=471997)

<br />
<hr />
<br />

## 높은 응집도와 늦은 결합도

- 개방 폐쇄 원칙은 높은 응집도와 낮은 결합도(high coherence and low coupling)라는 소프트웨어 개발의 고전적인 원리로도 설명이 가능하다.
- 응집도가 높다는 건 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 것을 의미한다.
- 불필요하거나 직접 관련이 없는 외부의 관심과 책임이 얽혀 있지 않으며, 하나의 공통 관심사는 한 클래스에 모여 있다.
- 높은 응집도는 클래스 레벨뿐 아니라, 패키지, 컴포넌트, 모듈에 이르기까지 그 대상의 크기가 달라도 동일한 원리로 적용될 수 있다.

<br />

### 높은 응집도

 - 응집도가 높다 => 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다.
> 변경이 일어날 때 모듈의 많은 부분이 함께 바뀐다면 응집도가 높다고 말할 수 있다.

> 모듈의 일부분에만 변경이 일어나도 된다면, 모듈 전체에서 어떤 부분이 바뀌어야 하는지 파악해야하고, 그 변경으로 인해 바뀌지 않는 부분에는 다른 영향을 미치지는 않는지 확인해야 하는 이중의 부담이 생긴다.

```
처음에 만든 초난감 DAO에서 DB 커넥션을 만드는 기능을, DriverManager를 이용한 방법에서 다른 DB 커넥션 풀 라이브러리를 사용하는 방법으로 변경한다고 했을 때 초난감 DAO처럼 여러 관심사와 책임이 얽혀 있는 복잡한 코드에서는 변경이 필요한 부분을 찾아내는 것도 번거로운 일일뿐더러, 그렇게 변경한 것이 DAO의 다른 기능에 영향을 줘서 오류를 발생시키지는 않는지도 일일이 확인해야 한다.

반면 ConnectionMaker 인터페이스를 이용해 DB 연결 기능을 독립시킨 경우라면, DB 커넥션 풀을 활용하는 ConnectionMaker 구현 클래스를 새로 만들기만 하면 된다. 기존에 구현한 DConnectionMaker를 일부 수정하더라도 마찬가지다.

작업은 항상 전체적으로 무엇을 변경할지 명확하며, UserDao 등 다른 클래스의 수정을 요구하지 않을뿐더러, 기능에 영향을 주지 않는다는 사실을 손쉽게 확인할 수 있다. 

DB 연결 방식에 변경이 일어난 경우에 이를 검증하려고 한다면, 변경한 ConnectionMaker 구현 클래스를 직접 테스트해보는 것만으로도 충분하기 때문이다. 기존의 NConnectionMaker를 개선해서 버전 2.0으로 만들었다고 하자. 수정된 NConnectionMaker를 테스트하기 위해 이를 사용하는 모든 DAO를 다 일일이 테스트해야 할까? 새로 만든 NConnectionMaker를 직접 테스트해도 충분하다. ConnectionMaker를 분리해서 응집도를 노인 덕분이다.
```

### 낮은 결합도
